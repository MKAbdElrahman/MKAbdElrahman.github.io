<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Architecture on Mohamed Kamal</title>
    <link>https://mkabdelrahman.github.io/categories/software-architecture/</link>
    <description>Recent content in Software Architecture on Mohamed Kamal</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 03 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mkabdelrahman.github.io/categories/software-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sagas Quantatively: Epic Saga</title>
      <link>https://mkabdelrahman.github.io/posts/saga-epic/</link>
      <pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/saga-epic/</guid>
      <description>When we transition to microservices, each service owns its data. Achieving transactions across multiple services isn&amp;rsquo;t as straightforward as with a single monolithic database.&#xA;One way to address this challenge is through sagas, which simulate distributed transactions using a series of local transactions. This approach was popularized by Chris Richardson and later analyzed by Mark Richards and Neal Ford in their book &amp;lsquo;Sotware Architecture: The Hard Parts&amp;rsquo;.&#xA;They examined how these factors affect saga characteristics:</description>
    </item>
    <item>
      <title>Microservices: Why Not a Shared Monolithic Database?</title>
      <link>https://mkabdelrahman.github.io/posts/why-not-shared-db/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/why-not-shared-db/</guid>
      <description>In microservices, the idea of using a shared monolithic database is always rejected. There are several reasons why this approach is not advisable. Below are the key considerations that highlight the drawbacks of a shared monolithic database.&#xA;Change Control Link to heading Managing changes in a shared monolithic database is a complex task. Any schema change necessitates coordination across all dependent services, which can be cumbersome and time-consuming. This coordination is required to ensure that all services are redeployed simultaneously to prevent schema mismatch errors, which can cause significant downtime and service disruption.</description>
    </item>
    <item>
      <title>Data Sharing Between Microservices Using Synchronized Embedded Caches</title>
      <link>https://mkabdelrahman.github.io/posts/caching_data-shraing-embedded-cache/</link>
      <pubDate>Thu, 27 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/caching_data-shraing-embedded-cache/</guid>
      <description>Setting the Scene Link to heading Consider an online food delivery system with two essential microservices:&#xA;Menu Service: Manages the list of available dishes. Order Service: Allows customers to create and manage their orders. How It Works Link to heading Starting the Menu Service:&#xA;The menu service starts and loads a cache containing information about available dishes. This cache is distributed, enabling it to be shared across different services. Starting the Order Service:</description>
    </item>
    <item>
      <title>Caching: Topologies and Patterns</title>
      <link>https://mkabdelrahman.github.io/posts/caching_patterns/</link>
      <pubDate>Wed, 26 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/caching_patterns/</guid>
      <description>What is a Cache? Link to heading A cache is a secondary data store that’s faster to read from than the data’s primary store. The purpose of a cache is to improve application performance by:&#xA;Reducing network calls to the primary data store: Instead of repeatedly querying the database, the cache handles data retrieval, offloading processing from the database. This reduces database connection consumption, often a limiting factor, and allows the database to perform faster.</description>
    </item>
    <item>
      <title>EDA Patterns: Thin and Thick Events</title>
      <link>https://mkabdelrahman.github.io/posts/eda-patterns-thin-thick-events/</link>
      <pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/eda-patterns-thin-thick-events/</guid>
      <description>Event-driven systems (EDS) rely on exchanging events for communication. Other services subscribe to these events and react accordingly. This loose coupling keeps services unaware of each other, with the only connection being the event&amp;rsquo;s data format. Since events act as contracts, careful design and consideration for future changes are crucial.&#xA;Scenario: Imagine an e-commerce application. When a customer submits an order, the order service emits an &amp;ldquo;order-requested&amp;rdquo; event. Both the payment service and inventory service are interested in this event.</description>
    </item>
    <item>
      <title>EDA Patterns: The Single Writer Principle</title>
      <link>https://mkabdelrahman.github.io/posts/eda-single-write-principle/</link>
      <pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/eda-single-write-principle/</guid>
      <description>The Single Writer Principle states that only one service should be responsible for making changes to a specific type of data or event.&#xA;Let&amp;rsquo;s consider an e-commerce system with separate services for Orders, Payments, and Shipments. In this scenario, the Order service serves as the single writer for all order-related data. Here&amp;rsquo;s how it works:&#xA;When a customer clicks &amp;ldquo;buy,&amp;rdquo; the Basket service triggers an &amp;ldquo;Order Requested&amp;rdquo; event. The Order service receives this event, validates the order details, and publishes an &amp;ldquo;Order Confirmed&amp;rdquo; event if successful.</description>
    </item>
    <item>
      <title>EDA Patterns: Event sourcing &amp; CQRS</title>
      <link>https://mkabdelrahman.github.io/posts/cqrs/</link>
      <pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/cqrs/</guid>
      <description>Event sourcing is a data management approach that centers around events, recognizing them as the core building blocks of any system. These events, representing state changes, are stored in an immutable append-only log, preserving the order they occurred in. This approach offers a comprehensive audit trail of the system&amp;rsquo;s activity and allows replaying the event log to reconstruct the current system state.&#xA;CQRS, or Command Query Responsibility Segregation, complements event sourcing by advocating for the separation of write operations (commands) and read operations (queries).</description>
    </item>
    <item>
      <title>EDA Patterns: Idempotent Integration with a Third-Party REST API</title>
      <link>https://mkabdelrahman.github.io/posts/idempotentintegrationwithathird-partyrestapi/</link>
      <pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/idempotentintegrationwithathird-partyrestapi/</guid>
      <description>Scenario:&#xA;You have an event-driven application that needs to integrate with a third-party REST API (Service B) without modifying it. To ensure reliable message processing, you want to introduce Service A as a mediator that consumes events and interacts with Service B in an idempotent manner.&#xA;Idempotency Requirement:&#xA;Service A: Service A must be idempotent to prevent duplicate event processing. This means if the same event is received multiple times, Service A should only process it once.</description>
    </item>
    <item>
      <title>Software Architecture: Partitioning Strategies</title>
      <link>https://mkabdelrahman.github.io/posts/head-first-architecture-partitioning/</link>
      <pubDate>Tue, 02 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/head-first-architecture-partitioning/</guid>
      <description>Distributed or Single Process Link to heading Single Process Application: A self-contained program that executes on a single computer. It handles all its processing tasks, data storage, and retrieval using the local machine&amp;rsquo;s resources (memory and storage). Examples include offline games and mobile apps without network functionality.&#xA;Distributed System: A software program designed to function across multiple computers connected over a network. These applications are broken down into smaller components that run on different machines.</description>
    </item>
    <item>
      <title>Software Architecture: Architectural Characteristics</title>
      <link>https://mkabdelrahman.github.io/posts/hfsa-architectural-charcteristics-part-1/</link>
      <pubDate>Fri, 29 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/hfsa-architectural-charcteristics-part-1/</guid>
      <description>Why Architectural Characteristics Link to heading Architectural characteristics are fundamental to making informed decisions throughout the software development process. Here&amp;rsquo;s why they&amp;rsquo;re important:&#xA;Guiding Architectural Decisions: Without a clear understanding of these characteristics, it&amp;rsquo;s difficult to make informed choices about your application&amp;rsquo;s structure.&#xA;Selecting an Architectural Style: Different architectural styles are better suited for specific needs. Analyzing characteristics helps you choose the most appropriate style for your project.&#xA;What are Architectural Characteristics?</description>
    </item>
    <item>
      <title>Software Architecture Vs. Design</title>
      <link>https://mkabdelrahman.github.io/posts/head-first-software-architecture-and-design/</link>
      <pubDate>Wed, 27 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/head-first-software-architecture-and-design/</guid>
      <description>Architecture is primarily concerned with the structure of the system, including its services, databases, and how they communicate with each other. Design, on the other hand, focuses more on the easy to change later decesions like choosing a specific design pattern or whether to split a class or not.&#xA;The line between architecture and design can sometimes be blurry. Understanding the difference, however, is crucial for determining who should make key decisions throughout a project.</description>
    </item>
    <item>
      <title>Software Architecture: A 4-Dimensional View</title>
      <link>https://mkabdelrahman.github.io/posts/head-first-architecture-dimensions/</link>
      <pubDate>Tue, 26 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://mkabdelrahman.github.io/posts/head-first-architecture-dimensions/</guid>
      <description>Software Architecture: A 4-Dimensional View Link to heading Software architecture isn&amp;rsquo;t a singular concept, but rather a multi-dimensional approach to building robust and adaptable systems. Let&amp;rsquo;s explore these key dimensions:&#xA;1. Architectural Characteristics&#xA;Architectural characteristics are the essential capabilities your system needs to possess. They determine how the system will perform, like speed (performance) and uptime (availability). These are also known as &amp;ldquo;ilities&amp;rdquo; for the suffix they often share (scalability, reliability, etc.</description>
    </item>
  </channel>
</rss>
